# Лабораторная работа №3:Salt and pepper
***

## Постановка задачи:

Реализовать алгоритм медианного фильтра.
 
Язык: __Python__

Технологии: __CUDA__

Входные данные: изображение в оттенках серого.

Выходные данные: очищенное изображение + время вычисления.

## Описание работы программы:
Работа программы делиться на 3 основных раздела:
1) Добавление шума в исходное изображение с помощью функции add_noise:
   Данная функция заменяет случайные пиксели на белые и черные.
   ```
   row, col = img.shape
    total_pixels = row * col
    number_of_noise_pixels = int(total_pixels * noise_percentage)  # Количество пикселей с шумом

    for _ in range(number_of_noise_pixels // 2):
        y_coord = random.randint(0, row - 1)
        x_coord = random.randint(0, col - 1)
        img[y_coord][x_coord] = 255  # белый пиксель

    for _ in range(number_of_noise_pixels // 2):
        y_coord = random.randint(0, row - 1)
        x_coord = random.randint(0, col - 1)
        img[y_coord][x_coord] = 0  # черный пиксель
   ```
2) Применение медианного фильтра:
   Вывбирается окно пикселей -> все значения в окне соритруются, и медианное значение присваивается текущему пикселю в выходном изображении.
   Функция обрабатывается каждый пиксель изображения, заменяя его медианным значение из соседних пикселей.
```
    # Вычисление индекса текущего потока
    x, y = cuda.grid(2)
    height, width = input_image.shape
    pad = window_size // 2

    # Проверка границ изображения
    if x >= height or y >= width:
        return

    # Сборка окна
    window = []
    for dx in range(-pad, pad + 1):
        for dy in range(-pad, pad + 1):
            nx, ny = x + dx, y + dy
            if 0 <= nx < height and 0 <= ny < width:
                window.append(input_image[nx, ny])

    # Сортировка и нахождение медианы
    window.sort()
    output_image[x, y] = window[len(window) // 2]
```
![image](https://github.com/user-attachments/assets/910be1b9-20c4-48b0-a53a-3e2732facd87)
3) График восстановления изображдения:
График, представленный на изображении, отображает зависимость между оригинальными значениями пикселей изображения и восстановленными значениями после обработки.

Диагональная линия (красная пунктирная линия) показывает идеальное восстановление, когда оригинальные и восстановленные значения совпадают.
Точки на графике распределены вокруг этой линии, что указывает на то, что восстановленные значения близки к оригинальным, но имеются отклонения, особенно при значениях пикселей, близких к 0 и 255. Это может означать, что на восстановленных данных присутствуют небольшие ошибки или шум.
Чем ближе точки к диагональной линии, тем точнее восстановление.
Вывод: Восстановление изображения прошло успешно, но не без небольших отклонений от идеала.
![image](https://github.com/user-attachments/assets/5a6dd26e-d440-44ef-bd15-f0818c1c9f82)


